---
title:  "Option pricing & Simulating Stochastic Differential Equations"
layout: post
---

<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 200%; background: inherit; border: inherit;}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
         chtml: {
            scale: 1.3
        },
        svg: {
            scale: 1.3
        },
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>


A European call option gives the owner the right to acquire the underlying security at expiry. For an investor to profit from a call option, the stock's price, at expiry, has to be trading high enough above the strike price to cover the cost of the option premium.

$\huge{payoff = max(S_T-K,0) = (S_T-K)^+ =(S_T-K)1_{S_T>K}}$

```python
def payoff(x, K):
    payoff_lambda = lambda x: max(x-K, 0)
    return np.array(list(map(payoff_lambda, x)))
```

The stock price is assumed to be driven by the following stochastic differential equation
$$\huge{dS_t = S_t r dt + S_t \sigma d W_t ~~~~~ S_0=s_0}$$
where $S_t$ is the price of the stock at time $\huge{t}$, $\huge{r}$ is the risk-free rate, $\huge{\sigma}$ is the volatility and $\huge{W_t}$ is a Brownian motion. The price of the option is the expected value of the discounted cashflow the security generates, that is $$\huge{V(t) = \mathbb{E}[e^{-r(T-t)}(S_T-K)^+]}$$


Black-Scholes formula

```python
def black_scholes(s0, K, T, r, sigma):
    d_1 = (np.log(s0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d_2 = (np.log(s0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    price = s0 * norm.cdf(d_1, 0, 1) - K * np.exp(-r * T) * norm.cdf(d_2, 0, 1) 
    return price
```

Exact Simulation

```python
def exact_simulation(M, s0, K, T, r, sigma):
    s1 = s0 * np.exp((r - sigma ** 2 / 2) * T + sigma * np.random.normal(loc=0, scale=np.sqrt(T), size=M))
    estimates = np.exp(-r * T) * payoff(s1, K)
    return np.mean(estimates)
```

Euler Scheme



```python
def euler_scheme(M, N, s0, K, T, r, sigma):
    dt = 1/N
    s = s0 * np.ones(M)
    for step in range(N):
        normal = np.random.normal(loc=0, scale=1, size=M)
        s = s + s * r * dt + s * sigma * np.sqrt(dt) * normal
    estimates = np.exp(-r * T) * payoff(s, K)
    return np.mean(estimates)
```

![png](../images/2022-02-03-options/stock.png)

Binomial Tree

```python
def binomial_tree(M, N, s0, K, T, r, sigma):
    dt = 1/N
    s = s0 * np.ones(M)
    for step in range(N):
        bernoulli = 2*np.random.randint(0,2,size=(M))-1
        s = s + s * r * dt + s * sigma * np.sqrt(dt) * bernoulli
    estimates = np.exp(-r * T) * payoff(s, K)
    return np.mean(estimates)
```


![png](../images/2022-02-03-options/confidence.png)