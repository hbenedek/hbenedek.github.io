---
title:  "Application of Monte-Carlo Methods to Community Detection"
layout: post
---

<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 200%; background: inherit; border: inherit;}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
         chtml: {
            scale: 1.3
        },
        svg: {
            scale: 1.3
        },
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>

This project was part of the course [COM-516 Markov Chains and Algorithmic Applications](https://edu.epfl.ch/coursebook/en/markov-chains-and-algorithmic-applications-COM-516) at EPFL fall 2021. We aimed to apply variants of the Metroplois-Hasting algorithm to one of the simplest models of the community detection problem (Stochastic Block Model) and to compute the perforemence and properties of these methods.

Check out the project on [Github](https://github.com/hbenedek/mcmc-community-detection). Special thanks to my teammates Daniel Suter and Guilhem Sicard.

    
TODO:
    - include image of example graph
    - fix latex
    
# Problem formulation and the Stochastic Block Model

We assume we are given an observation graph $\huge{G=(V, E)}$ and we aim to revocer two communities, that is we are looking for a vector $\huge{x^*\in \\{-1,1\\}^{\lvert V \rvert}}$. We use the [Stochastic Block Model](https://en.wikipedia.org/wiki/Stochastic_block_model) to explain how the graph was generated. First each node is assigned to one of the communities with $\huge{\frac{1}{2}}$ probability, if the number of nodes is large enough, the two communities are similar in size. Then we generate edges between the nodes $\huge{i}$ and $\huge{j}$ with the probabilities
    $$ \begin{equation} \huge{\mathbb{P}(e_{ij}\in E| x^*_i x^*j = +1 )=\frac{a}{N}
    \mathbb{P}(e_{ij}\in E| x^*_ix^*_j = -1)=\frac{b}{N}} \end{equation} $$

where $\huge{a}$ and $\huge{b}$ are real numbers.

We will follow a Bayesian approach for our model, that is we will derive the posterior distribution of the community vectors given the edges in our graph
    $$ \begin{equation}  
    \huge{\mathbb{P}(x| E) = \frac{\mathbb{P}(E |x)\mathbb{P}(x){\mathbb{P}(E)}
    \end{equation}  = \frac{\prod_{i,j}\mathbb{P}(e_{ij}|x_i x_j)\prod_i \mathbb{P}(x_i)}{sum_{x \in \{\pm 1\}^\lvert V \rvert} \prod_{i,j} \mathbb{P}(e_{ij}|x_i x_j)\prod_i \mathbb{P}(x_i)}$$


 
    - Measure our predictions performance
# Monte Carlo approach
    - Metropolis algorithm

# Community detection on the Twitch graph
    - What is the graph? 
    - What are the communities we weant to recover?
    - How was the SBM applied?
    - Results and plots
